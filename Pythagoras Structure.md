Basic Introduction
=======================

Pythagoras is written in Visual C++, using Visual Studio Community 2019.  At the time of writing, this was version 16.5.5. Details about how to compile Pythagoras, including 
library dependencies, can be found in the "Compiling Pythagoras.md" file.  The purpose of this document is to detail some of the inner workings of the code, to make it easier for other people (e.g. you) to understand the code and debug/improve it.  There are two main executables that the client user routinely works with.  These are Pythagoras.exe and PythagorasEngine.exe.  Pythagoras.exe is the main GUI application, and is where all of the MFC UI functionality is located.  PythagorasEngine.exe is where all of the Python script execution occurs. It is common for the Python scripts to trigger GUI events, such as displaying HTML forms or messageboxes.  These are handled within PythagorasEngine.exe, itself an MFC application, and not within the main Pythagoras.exe.  In this way, there is complete separation from the Python script execution environment and the Pythagoras.exe environment.  More details on this will be described below, but it can be said that Pythagoras.exe is just the GUI side of things that allows users to select Python scripts and data files, and then call functions within those Python scripts.  All logic for actually running Python scripts is handed off to PythagorasEngine.exe.

The reason for splitting the GUI code from the Python script execution code has to do with limitations of the Python embedding functionality.  Despite repeated attempts to call multiple Python scripts from within the GUI application, I could never get them to work properly.  A call to the PyInitialize() function in the Python library creates some state within Python that cannot be completely undone or unloaded.  Repeated calls to functions within a Python module would invariably generate exceptions.  Further investigation on the Internet revealed that this was a common problem when embedding Python scripts within a C++ program, and the only remedy was to completely isolate the Python environment from the C++ environment.  I attempted to initialize and call Python methods only within unique threads, but that was not successful.  The only way to unwind the PyInitialize() state was to completely unload the entire executable that called PyInitialize() and start over.  This is where PythagorasEngine.exe comes into play.  Pythagoras was intially developed when Python was at version 3.6.x, in 2016/2017.  It's possible that this issue with embedding Python within C++ has been fixed; however, it is not worth the time and effort to attempt to go back and roll everything together into a single application.

Communication between Pythagoras.exe and PythagorasEngine.exe is handled using the Boost::interprocess library.  This library allows for sharing blocks of memory between applications, which greatly simplifies the process of sending data back and forth.  The basic flow is as follows: a thread is created within Pythagoras.exe to initialize the shared memory space using a Mutex to guard against multiple threads accessing the shared memory.  This Pythagoras.exe thread then sets data within the shared memory space, including a list of files to process, the filename of the Python script to execute, the name of the method within the script, along with a handful of other variables such as temporary file paths, default HTML templates, etc.  The thread then does a CreateProcess() on PythagorasEngine.exe and goes into a wait state, waiting on the launched executable to finish.  Meanwhile, the main Pythagoras.exe thread is still functioning as normal so there is no disruption to the user.  When PythagorasEngine.exe launches, the first thing it does is map into the shared memory space to determine what it needs to do.  It then loads the requested script, generates the Python variables that get passed into the function (e.g. the list of files to process), and finally calls that Python function.  After the function finishes, PythagorasEngine.exe places any output data into the shared memory space and terminates.  The waiting thread in Pythagoras.exe then wakes up and resumes its activity, including retrieving any output data from the shared memory space and finally cleaning up/removing the shared memory.  More details on the structure of the shared memory will be described below.

Local and Common Scripts
=======================

Suffice it to say, Pythagoras.exe is a rather useless program without some Python script to call.  The task of finding Python scripts and parsing through their embedded methods is handled by Pythagoras.exe and is described below.  In this section, I will describe the overall layout of the local and common directory structures, and how those structures are manipulated by Pythagoras.exe to generate the list of scripts and methods.  

Local scripts are meant to be editable by the user, and seen only by that particular user.  A user cannot see local scripts that others have created.  Common scripts, on the other hand, are designed to NOT be editable by the user, and instead shared by all users.  In this way, the user has some control over creating scripts and making their own changes, but these changes are not reflected in the common scripts that all users would see.  The administrators (the author and ostenibly you, the reader) would have control over the common scripts and make changes only when necessary.  Users can create their own local scripts, but they cannot (by default) create common scripts.

To enforce control over the common scripts, the application will (by default) connect to an FTP server and download a zip file that contains all of the common scripts.  This happens automatically when the application is first launched, as well as any time the "Refresh Scripts" button is pressed within the GUI.  This zip file is presently maintained by the author, and there is only (at present) one global zip file that all users would access.  The application includes a user-editable configuration setting that would allow for individual users, or even groups of users, to connect to different FTP servers, or different FTP users, and thus download different common zip files.

When the application is launched for the very first time on a computer, it will go through and create a directory structure under MyDocuments\Pythagoras.  This structure would have Scripts\Local and Scripts\Common folders, where all such scripts would physically reside.  In this way, a user's local scripts are located physically on their C:\ drive, and thus visible only to them.  As mentioned previously, the Common files are downloaded from the FTP server on every refresh; however, these scripts are also physically located on the user's C:\ drive.  It should be noted that the user has control over where their local and common folders are located, by going to File...Settings from the main menu.  This allows a user to change the location of their local scripts, in case they wish to place them on a network drive so they are accessible from different computers.

When Pythagoras is first launched, or whenever a RefreshScripts() call is triggered, the application undergoes a file copy process.  A temporary folder underneath the application directory (e.g. C:\Program Files\3M\Pythagoras) is created, and all local and common scripts from the user's chosen folder structure are copied there.  Note that only .py and .html files are copied.  The actual parsing and execution of Python scripts is thus handled within this temporary folder on the user's hard drive, and NOT in the location where the scripts were initially located.  This is done for one major reason: a __pycache__ folder is automatically generated every time a Python script is compiled and executed.  This folder is located underneath the folder where the script is located.  If the user has chosen to locate their scripts on a network drive, it is possible that two different executables could be accessing the same network storage location simultaneously, and thus would clash over the __pycache__ directory structure and its contents.  By copying into a temporary folder, this potential contention is eliminated.  

For local scripts, the copy process is fairly straightforward: any and all .py and .html files in the user's chosen Local script folder are copied directly into the temporary folder (recursively).  For common scripts, the copy process may involve two steps: first, if the user has chosen to download the Common scripts from the FTP server (which is the default), then those files are downloaded directly into the temporary folder structure.  Second, if there are any .py and .html files in the user's chosen Common script folder, those files are copied into the temporary folder structure.  This second copy operation is set to overwrite any existing files if they are present.  Since this second copy follows the download from FTP step, the user actually has some control over the common files that Pythagoras interacts with.  A user can thus generate their own version of a common file, placing it in their chosen directory structure, and Pythagoras will not overwrite it.  This is not advertised directly to the users, and this is not the default configuration, but this is provided as a means for different groups of users to have different common files, or even for a savvy user to create their own Common file in case one of the functions is not working properly.

As an example, one way to configure a set of users is to set up their Pythagoras config so that their Common folder is pointed at a shared network drive (e.g. Q:\Pythagoras\EMSD\Common).  In addition, their application could be set up to NOT download common files from the FTP server.  In this way, those users would only see whatever local scripts they have, along with a select number of Common scripts that are only found within their shared network folder.  A second group of users could point to a completely different network drive (e.g. Q:\Pythagoras\TEGL\Common) with its own set of common files.

The application provides some basic rules around what types of scripts can be created and edited.  Only local scripts are editable by default from *within the application*.  Meaning, if a user right-clicks in the Tree control within Pythagoras, the popup window showing "Edit" and "New Script" only appears when they've selected the Local Scripts folder structure.  They cannot directly edit any common script from within Pythagoras; however, nothing prevents a user from manually editing a script within their chosen Common directory stucture.

Pythagoras.exe
=======================

Pythagoras.exe was created using the "single document/view" architecture common with MFC applications, using the "Visual Studio" project style.  This particular style provides a template application that looks very similar to Visual Studio itself: there's a dockable explorer-type window on the left with tabs, a dockable output window with tabs on the bottom, and a toolbox like dockable window on the right.  The toolbox window was removed, and the document-level window was replaced with a CFormView-derived window.  In this way, there is no real "document" underneath.  There is a PythagorasDoc.cpp, but this code is all boilerplate and noting of consequence happens here.  The File...Save and File...SaveAs functionality has all been stripped out.  The doc/view architecture was chosen to provide easy access the GUI functionality that comes with little effort in MFC doc/view apps.  

CPythagorasApp
----------------------
The main application where all of the heavy lifting is performed.  All Boost::interprocess shared memory functionality is handled within this class, along with any thread that is created to handle script execution.  All Python script executions are ultimately initiated within this class.  The act of creating the local and common script directory structures is handled here, along with downloading of common files from the FTP server.

One of the most important things that happens within this class is the parsing of Python scripts.  Rather, this class is responsible for generating a list of .py files found within the Local and Common

CPythagorasView
-----------------------
CPythagorasView is derived from CFormView.  This class handles the main body of the GUI, where the listbox of files/folders is located, alongside the tabbed windows such as Explorer/Database/Regex.  This class essentially provides a framework to store a list of files to process, and to handle button press events on the main form.  When a list of files have been prepared for sending to a script, the code calls theApp.ExecuteScript(), which